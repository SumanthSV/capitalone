# KrishiMitra Deployment Guide

## Production Deployment Steps

### 1. Prerequisites
- Python 3.8+
- Git
- Domain name (for HTTPS)
- SSL certificate
- Server with at least 2GB RAM

### 2. Setup Production Environment

```bash
# Clone the repository
git clone <your-repo-url>
cd krishimitra

# Run production setup
python setup_production.py
```

### 3. Configure Environment Variables

Update your `.env` file with production values:

```bash
# Required API Keys
GEMINI_API_KEY=your_actual_gemini_api_key
OPENWEATHER_API_KEY=your_actual_openweather_api_key

# Security (generated by setup script)
SECRET_KEY=your_generated_secret_key
JWT_SECRET_KEY=your_generated_jwt_secret_key

# Production settings
DEBUG=false
LOG_LEVEL=INFO
ALLOWED_ORIGINS=https://yourdomain.com

# Optional services
ENAM_API_KEY=your_enam_api_key
NOTIFICATION_EMAIL=your_email@gmail.com
NOTIFICATION_EMAIL_PASSWORD=your_app_password
```

### 4. Initialize Crop Database

If you have the crops dataset:
```bash
python import_crops.py
```

### 5. Deployment Options

#### Option A: Direct Deployment
```bash
# Start the application
./start.sh
```

#### Option B: Docker Deployment
```bash
# Build and run with Docker Compose
docker-compose up -d
```

#### Option C: Cloud Deployment

**Heroku:**
```bash
# Create Procfile
echo "web: python -m uvicorn web_app.main:app --host 0.0.0.0 --port \$PORT" > Procfile

# Deploy
git add .
git commit -m "Production ready"
heroku create your-app-name
git push heroku main
```

**Railway:**
```bash
# Connect your GitHub repo to Railway
# Set environment variables in Railway dashboard
# Deploy automatically on push
```

### 6. SSL/HTTPS Setup

For production, always use HTTPS:

```bash
# Using Nginx as reverse proxy
sudo apt install nginx certbot python3-certbot-nginx

# Get SSL certificate
sudo certbot --nginx -d yourdomain.com

# Nginx configuration
server {
    listen 80;
    server_name yourdomain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl;
    server_name yourdomain.com;
    
    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
    
    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### 7. Monitoring and Maintenance

#### Health Checks
- Monitor `/api/health` endpoint
- Check `/api/status` for service status
- Monitor logs in `logs/krishimitra.log`

#### Database Backups
```bash
# Backup databases
cp crop_data.db backups/crop_data_$(date +%Y%m%d).db
cp users.db backups/users_$(date +%Y%m%d).db
cp community.db backups/community_$(date +%Y%m%d).db
```

#### Performance Monitoring
- Monitor CPU and memory usage
- Check response times
- Monitor API rate limits

### 8. Security Checklist

- ✅ HTTPS enabled
- ✅ Strong secret keys
- ✅ Input validation
- ✅ Rate limiting
- ✅ CORS properly configured
- ✅ User authentication
- ✅ SQL injection protection
- ✅ XSS protection

### 9. Scaling Considerations

For high traffic:
- Use multiple worker processes
- Implement Redis for caching
- Use PostgreSQL instead of SQLite
- Set up load balancing
- Use CDN for static assets

### 10. Troubleshooting

Common issues and solutions:

**Database locked errors:**
- Switch to PostgreSQL for production
- Ensure proper connection pooling

**Memory issues:**
- Increase server RAM
- Optimize image processing
- Implement proper caching

**API rate limits:**
- Implement exponential backoff
- Cache API responses
- Use multiple API keys if available

## Support

For deployment issues:
- Check logs in `logs/krishimitra.log`
- Monitor `/api/status` endpoint
- Review environment variables
- Ensure all required services are running